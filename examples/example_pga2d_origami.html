<HEAD>
  <SCRIPT SRC="../ganja.js"></SCRIPT>
</HEAD>
<BODY><SCRIPT>
// Create a Clifford Algebra with 2,0,1 metric.
Algebra(2,0,1,()=>{

  // Prototype PGA implementation of 2D origami folding.
  // https://easychair.org/publications/paper/8jDf
  
  // First four Huzita-Hatori axioms 
  var Ori1 = (p1,p2)=>p1&p2,
      Ori2 = (p1,p2)=>(p1&p2)<<(p1+p2).Normalized,
      Ori3 = (l1,l2,flag)=>flag?(l1+l2):(l1+l2)<<(l1^l2),
      Ori4 = (p1,l1)=>l1.Normalized<<p1.Normalized;

  // Quick and dirty folder that splits and ignores connectivity updates.
  // Takes a figure O, fold line l, list of faces to fold f. Returns updated O. 
  var Ori = (O,l,f) => {
      var res=[]; O.forEach((s,si)=>{ 
        if (f.indexOf(si)==-1) return res.push(s);                              // no split needed
        var signs = s.map(p=>Math.sign(((p/p.e12)^l).e012.toFixed(2)));         // side of ray points are on
        var t=[]; s.forEach((x,i)=>{                                            // loop over edges
            var j=(i+1)%s.length; t.push(x.Normalized);                         // insert vertex
            if (signs[i]&&signs[j]&&signs[i]!=signs[j]) t.push((x&s[j]^l))      // insert cut point
        });
        signs = t.map(p=>Math.sign(((p/p.e12)^l).e012.toFixed(2)));             // recalc signs
        res.push(t.filter((p,i)=>signs[i]<=0).map(x=>(l>>>x)).map(x=>x/x.e12),  // push turned face
                 t.filter((p,i)=>signs[i]>=0).map(x=>x/x.e12));                 // push split face
      })
      return res;
  }

  // The first few steps for Kabuto.
  var point = (x,y)=>1e12-x*1e01+y*1e02;
  var s = 0.8, p1 = point(-s,s), p2 = point(-s,-s), p3 = point(s,-s), p4 = point(s,s);
  
  var O0 = [[p1,p2,p3,p4]],
      O1 = Ori(O0,Ori2(p1,p3),[0]),
      O2 = Ori(O1,Ori2(p4,p3),[0,1]),
      O3 = Ori(O2,Ori2(p2,p3),[1,3]);

  document.body.appendChild(this.graph(["Origami - Kabuto", 0xAAAAAA].concat(O0-1e01+1e02,O1-1e01-1e02,O2+1e01+1e02,O3+1e01-1e02)));
});
</SCRIPT></BODY>